<!DOCTYPE html>
<html>
<link rel="stylesheet" href="/css/blueprint/screen.css" type="text/css" media="screen">
<link rel="stylesheet" href="/css/blueprint/print.css" type="text/css" media="print">

<head>
  <meta charset="utf-8"/>

  <title>Phonetic Keyboard map {{language}}</title>

  <!-- Font encoding areas -->
  <style>
  <!-- Unicode fonts -->

    @font-face{
      font-family:'Arial';
      font-weight:normal;
      font-style:normal;
    }
    .Arial {
      font-family:Arial;
      font-size: 30px;
    }
  {% for font in unicode_list %}
    @font-face {
      font-family:'{{font.family}}';
      src:url('{{font.source}}'){% if '.ttf' in font.source %}format('truetype'){%endif%}{% if '.TTF' in font.source %}format('truetype'){%endif%}{% if '.otf' in font.source %}format('opentype'){%endif%}{%if '.woff' in font.source %}format('woff'){%endif%};
      font-weight:normal;
      font-style:normal;
      font-size: 32px;
    }

    .{{font.family}} {
      font-family:'{{font.family}}';
      font-size: 32px;
    }
    {% endfor %}

  {% for kb in kb_list %}{% if kb.fontFamilyToApply %}
  .{{kb.fontFamily}} {
      font-family:{% for font in kb.fontFamilyToApply %}' {{font}}'{% if not forloop.last %},{%endif%}{% endfor %}
  }{%endif%}{% endfor %}

  </style>
  <style>
    table {
      border-collapse: collapse;
    }

    table, th, td {
      border: 1px solid black;
    }
    td {
    text-align: center;
    width: 120px;
    font-size:20px;
    <!-- preformat text in cells -->
    white-space:pre;
    }

  </style>
  <script src="/js/baseConverter.js"></script>

  {% if converter_list %}
  <script src="{{converterJS}}"></script>
  {% endif %}

  <script>
  // Global for processing text 
    let textFuncs;
    </script>
  {% if text_functions %}
  <script src="/{{text_functions}}"></script>
  {% else %}
  <script>
    let textFunctions;
    </script>
  {% endif %}

  <!-- Path to convert with code tables and other  this for the converter. -->
  <script src="/js/utils.js"></script>

  <script>
    let utils = new Utils();

    // Global for processing text 
    if (textFunctions != undefined) {
        textFuncs = new textFunctions();
    }
        
  var k = { loadme: Object};

  k.loadme.prototype = function(a) {
  return a;
  }
  var e = {keyboard: k};
  var google = {elements: e};
  </script>

  {% for kb in kb_list %}
  <!-- {{kb.shortName}} -->
  <script src="/layouts/{{kb.shortName}}.js"></script>
  {% endfor %}

  <script>
  var kb_list = []; //
  var kb_fonts = [];
  {% for kb in kb_list %}
  kb_list.push({{kb.shortName}}); kb_fonts.push("{{kb.fontFamily}}");
  {% endfor %}

  const unicode_font_list = [
    {% for font in unicode_list %}"{{font.family}}",{% endfor %}
  ];

  {% if converter_list %}{% for conversion in converter_list.conversions %}
    var {{conversion}} = {{converter_list.convert_obj}}['conversions']['{{conversion}}'].convert;
    {% endfor %}
  {% endif %}
  {% if converter_list %}
  // TODO: update to work with more than Tangsa conversions.
  var converter_PUA_to_Unicode = nstConverter_obj['conversions']['GW_to_Unicode'].convert;
  {% endif %}

  var reverse_sort = false;
  // Convert to Tangsa Unicode to compare PUA values
  function compareRowsByColumnUnicode(a, b) {
  {% if converter_list %}
    a = converter_PUA_to_Unicode(a);
    b = converter_PUA_to_Unicode(b);
  {% endif %}
    if (reverse_sort) {
      if (a > b) {
       return -1;
      } else if (a < b) {
       return 1;
      }
      return 0;
    } else {
      if (a < b) {
       return -1;
      } else if (a > b) {
        return 1;
      }
      return 0;
    }
  }

  function onPageLoaded() {
    buildingTransformTable();
  }

  {% if converter_list %}
  {% for conversion in converter_list.conversions %}
    var {{conversion}} = {{converter_list.convert_obj}}['conversions']['{{conversion}}'].convert;
    {% endfor %}
  {% endif %}

  {% if converter_list %}
  // TODO: update to work with more than Tangsa conversions.
  var converter_PUA_to_Unicode = nstConverter_obj['conversions']['GW_to_Unicode'].convert;
  {% endif %}

  var reverse_sort = false;
  // Convert to Tangsa Unicode to compare PUA values
    function compareRowsByColumnUnicode(a, b) {
        {% if converter_list %}
        a = converter_PUA_to_Unicode(a);
        b = converter_PUA_to_Unicode(b);
        {% endif %}
        if (reverse_sort) {
            if (a > b) {
                return -1;
            } else if (a < b) {
                return 1;
            }
            return 0;
        } else {
            if (a < b) {
                return -1;
            } else if (a > b) {
                return 1;
            }
            return 0;
        }
    }

    
    // Get all the patterns in all the lists.
    function createPatternMap(kb_list) {

	// things that should not make a new row in table
	const ignorableSet = textFuncs.ignoreInPhonetics();

        const patternMap = new Map();
        for (let kb_index in kb_list) {
            const kb = kb_list[kb_index];
            const this_transform = kb.transform;
            // Ignore if no transforms or just a placeholder
            if (!this_transform ||
                Object.keys(this_transform).length <= 1) continue;
            for (let pattern in this_transform) {
                // Try expanding pattern
                let expandedPatterns = utils.expandMatchRegEx(pattern);

		// The output of the pattern
		let result = this_transform[pattern];
		if (ignorableSet.has(result)) continue;  // Ignore
		for (let item of expandedPatterns) {
		    let lowerItem = item.toLowerCase();
                    if (result === item) continue;  // No point in identity!
                    let currentOutputs;
                    if (patternMap.has(lowerItem)) {
                        // Get the array.
                        currentOutputs = patternMap.get(lowerItem);
                    } else {
                        // A new one!
                        currentOutputs = new Set();
                    }
                    currentOutputs.add(result);
                    patternMap.set(lowerItem, currentOutputs);
                }
            }
        }
	return patternMap;
    }

    function buildingTransformTable() {
        if (kb_list === undefined) {
            return;
        }
	// Only do one keyboard !!! Only keyboards with transforms.
	let patternMap = createPatternMap(kb_list);

        const fontsize="24px";
        const cellWidth = "200px";


        // Just one table.
        let table = document.getElementById('column_table');
        const header = table.createTHead();
        let rowNum = 0;
        let headerRow = table.insertRow(rowNum);

        let cellIndex = 1;

        headerRow.insertCell(0).innerHTML = "LETTER";

        // Now build table based on the patternMap.
        let keyList = [...patternMap.keys()];
        if (textFuncs) {
            // Sort these 
            keyList = textFuncs.sortAsciiList(keyList);
        }    

	// Fill in vowels in the header
        let vowels = textFuncs.getVowels();

        cellIndex = 1;
        let numVowels = 0
        let vowelMap = new Map();
        for (vowel of vowels) {
            let lower = vowel.toLowerCase();
            if (!vowelMap.has(lower)) {
                vowelMap.set(lower, cellIndex);
                const headerCell = headerRow.insertCell(cellIndex);
                let mappedChars = patternMap.get(lower);
		if (mappedChars) {
                    headerCell.innerHTML = [...mappedChars] +
			'  (' + lower + ')';
		} else {
                    headerCell.innerHTML = '(' + lower + ')';
		}
		
                cellIndex ++;
                numVowels ++;
            }
        }
        
        // Generate the rows values by first item and columns by 2nd item in
        // the text split of the pattern key.
        let rowMap = new Map();
        for (let key of keyList) {
	    // Skip the vowels
	    if (vowelMap.has(key)) continue;
	    
            let split = textFuncs.splitText(key);
            let rowText = split[0];
            let colMap;
            if (rowMap.has(rowText)) {
                colMap = rowMap.get(split[0]);
            } else {
                colMap = new Map();
                rowMap.set(rowText, colMap);
            }
            let newColMarker = split.length > 1 ?
                split[1].toLowerCase() :
                vowels[0];
            let current = new Set();
            if (colMap.has(newColMarker)) {
                current = colMap.get(newColMarker);
            }
            let newEntry = patternMap.get(key);
	    // Add all of the newEntry to current.
	    for (const elem of newEntry) {
		current.add(elem);
	    }
            colMap.set(newColMarker, current);
        }

        // Make new table from phonetic info.
        rowNum = 1;
        let iterator1 = rowMap.entries();
        let entry;
        while (entry = iterator1.next().value) {
            let row = table.insertRow(rowNum);
            let cell0 = row.insertCell(0);
            cell0.innerHTML = entry[0];
            for (cellIndex = 1; cellIndex < numVowels +1; cellIndex ++) {
                cell = row.insertCell(cellIndex);
            }
            let cols = entry[1];  // The column map
            let iterator2 = cols.entries();
            let coldata;
            while (coldata = iterator2.next().value) {
                let vowel = coldata[0];
                if (vowelMap.has(vowel)) {
                    cellIndex = vowelMap.get(vowel);
                    let cell = row.cells[cellIndex];
		    let values = [...coldata[1]];  // Spread the set
                    cell.innerHTML = values.join(' ');
                }
            }
            rowNum ++;
        }
    }

    // Changes the Unicode font applied to each converted column in table.
    function setUnicodeFontColumns(unicodeFont, tableId) {
        const table = document.getElementById(tableId);
        const numberColumns = table.rows[0].cells.length;
        const numberRows = table.rows.length;

        // Unicode columns are 1, 2, , ...
        for (let col = 1; col < numberColumns; col += 1) {
            for (let row = 0; row < numberRows; row += 1) {
                const cell = table.rows[row].cells[col];
                if (cell) {
                    cell.style.fontFamily = unicodeFont;
                }
            }
        }
    }
  </script>
</head>

<body onload="onPageLoaded();">

<div class="container">
  <h1>{{language}} phonetic table</h1>
  <p>The following are transforms in a phonetic keyboard for {{language}}.
  <p>Hint: hover over the Unicode conversions for the hex code points.

    {% include "fontSelector.html" %}
    {% include "kbSelector.html" %}
  <div class="span-20">
    <table id='column_table' border='3'></table>
  </div>

</div>
</body>
</html>
